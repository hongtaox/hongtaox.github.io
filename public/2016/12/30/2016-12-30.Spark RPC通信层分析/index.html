<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Spark RPC通信层分析 | XCODER</title><link rel="stylesheet" type="text/css" href="//fonts.css.network/css?family=Source+Code+Pro"><link rel="stylesheet" type="text/css" href="/css/style.css?v=2.0.1"><link rel="stylesheet" type="text/css" href="/css/highlight.css?v=2.0.1"><link rel="Shortcut Icon" href="/favicon.ico"><link rel="bookmark" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Spark RPC通信层分析</h1><a id="logo" href="/.">XCODER</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div><div id="search-form"><div id="result-mask" class="hide"></div><label><input id="search-key" type="text" autocomplete="off" placeholder="Arama"></label><div id="result-wrap" class="hide"><div id="search-result"></div></div><div class="hide"><template id="search-tpl"><div class="item"><a href="/{path}" title="{title}"><div class="title">{title}</div><div class="time">{date}</div><div class="tags">{tags}</div></a></div></template></div></div></div><div id="layout" class="layout-g"><div class="layout-l"><div class="content_container"><div class="post"><h1 class="post-title">Spark RPC通信层分析</h1><div class="post-meta"><a href="/2016/12/30/2016-12-30.Spark RPC通信层分析/#comments" class="comment-count"></a><p><span class="date">Dec 30, 2016</span><span><a href="/categories/spark/" class="category">spark</a></span></p></div><div class="post-content"><p>　　Spark将RPC通信层设计的非常巧妙，融合了各种设计/架构模式，将一个分布式集群系统的通信层细节完全屏蔽，这样在上层的计算框架的设计中能够获得很好的灵活性。同时，如果上层想要增加各种新的特性，或者对来自不同企业或组织的程序员贡献的特性，也能够很容易地增加进来，可以避开复杂的通信层而将注意力集中在上层计算框架的处理和优化上，入手难度非常小。另外，对上层计算框架中的各个核心组件的开发、功能增强，以及Bug修复等都会变得更加容易。<br><a id="more"></a></p>
<h2 id="Spark-RPC"><a href="#Spark-RPC" class="headerlink" title="Spark RPC"></a>Spark RPC</h2><p>Spark 中的消息通信主要涉及 <code>RpcEnv</code>、<code>RpcEndpoint</code> 及 <code>RpcEndpointRef</code> 几个类。<br><img src="/resources/bigdata/spark-rpc-rpcenv.png" alt="spark rpc"></p>
<p>　　<code>RPCEndpoints</code>  定义了如何处理消息（即，使用哪个函数来处理指定消息）,在通过name完成注册后，<code>RpcEndpoint</code> 就一直存放在 <code>RpcEnv</code> 中。<code>RpcEndpoint</code> 的生命周期按顺序是 <code>onStart</code>，<code>receive</code> 及 <code>onStop</code>，<code>receive</code> 可以被同时调用，如果希望 <code>receive</code> 是线程安全的，可以使用 <code>ThreadSafeRpcEndpoint</code>。</p>
<p>　　<code>RpcEndpointRef</code> 是 <code>RpcEnv</code> 中的 <code>RpcEndpoint</code> 的引用，是一个序列化的实体以便于通过网络传送或保存以供之后使用。一个 <code>RpcEndpointRef</code> 有一个地址和名字。可以调用 <code>RpcEndpointRef</code> 的 <code>send</code> 方法发送异步的单向的消息给对应的 <code>RpcEndpoint</code>。</p>
<p>　　<code>RpcEnv</code> 管理各个 <code>RpcEndpoint</code> 并将发送自 <code>RpcEndpointRef</code> 或远程节点的消息分发给对应的 <code>RpcEndpoint</code>。对于 <code>RpcEnv</code> 没有 catch 到的异常，会通过 <code>RpcCallContext.sendFailure</code> 将该异常发回给消息发送者或记日志。</p>
<h2 id="RpcEnvFactory"><a href="#RpcEnvFactory" class="headerlink" title="RpcEnvFactory"></a>RpcEnvFactory</h2><p><code>RpcEnvFactory</code> 是构造 <code>RpcEnv</code> 的工厂类，调用其 <code>create(config: RpcEnvConfig): RpcEnv</code> 会 <code>new</code> 一个 <code>RpcEnv</code> 实例并返回。</p>
<p>Spark 中实现了两种 RpcEnvFactory：</p>
<ul>
<li>org.apache.spark.rpc.netty.NettyRpcEnvFactory 使用 netty</li>
<li>org.apache.spark.rpc.akka.AkkaRpcEnvFactory 使用 akka</li>
</ul>
<p>其中在 Spark 2.0 已经没有了 AkkaRpcEnvFactory，仅保留了 NettyRpcEnvFactory。在 Spark 1.6 中可以通过设置 spark.rpc 值为 netty （默认）来使用 NettyRpcEnvFactory 或设置为 akka 来使用 AkkaRpcEnvFactory，例如：</p>
<ul>
<li>$ ./bin/spark-shell –conf spark.rpc=netty</li>
<li>$ ./bin/spark-shell –conf spark.rpc=akka</li>
</ul>
<h2 id="RpcEnv"><a href="#RpcEnv" class="headerlink" title="RpcEnv"></a>RpcEnv</h2><p><code>Rpc Environment（RpcEnv）</code>是一个 <code>RpcEndpoints</code> 用于处理消息的环境，<code>RpcEnv</code> 必须通过工厂类 <code>RpcEnvFactory</code> 创建。<code>它管理着整个RpcEndpoints</code> 的声明周期：</p>
<p>（1）根据name或uri注册endpoints<br>（2）管理各种消息的处理<br>（3）停止endpoints</p>
<p><code>RpcAddress</code> 与 <code>RpcEndpointAddress</code><br><code>RpcAddress</code> 是一个 <code>RpcEnv</code> 的逻辑地址，包含 hostname 和端口，<code>RpcAddress</code> 像 Spark URL 一样编码，比如：<code>spark://host:port</code>。<code>RpcEndpointAddress</code> 是向一个 <code>RpcEnv</code> 注册的 <code>RpcEndpoint</code> 的逻辑地址，包含 <code>RpcAddress</code> 及名字，格式如：<code>spark://[name]@[rpcAddress.host]:[rpcAddress.port]</code></p>
<h3 id="RpcEnv抽象类"><a href="#RpcEnv抽象类" class="headerlink" title="RpcEnv抽象类"></a>RpcEnv抽象类</h3><p>一个 <code>RpcEnv</code> 是一个 <code>RPC</code> 环境对象，它负责管理 <code>RpcEndpoint</code> 的注册，以及如何从一个 <code>RpcEndpoint</code> 获取到一个 <code>RpcEndpointRef</code>。<code>RpcEndpoint</code> 是一个通信端，例如Spark集群中的 <code>Master</code>，或 <code>Worker</code>，都是一个 <code>RpcEndpoint</code>。但是，如果想要与一个 <code>RpcEndpoint</code> 端进行通信，一定需要获取到该<code>RpcEndpoint</code>一个 <code>RpcEndpointRef</code>，而获取该 <code>RpcEndpointRef</code> 只能通过一个 RpcEnv 环境对象来获取。所以说，一个 <code>RpcEnv</code> 对象才是RPC通信过程中的“指挥官”，在 <code>RpcEnv</code> 类中，有一个核心的方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">setupEndpoint</span></span>(name: <span class="type">String</span>, endpoint: <span class="type">RpcEndpoint</span>): <span class="type">RpcEndpointRef</span></div></pre></td></tr></table></figure></p>
<p>通过上面方法，可以注册一个 <code>RpcEndpoint</code> 到 <code>RpcEnv</code> 环境对象中，有 <code>RpcEnv</code> 来管理 <code>RpcEndpoint</code> 到 <code>RpcEndpointRef</code> 的绑定关系。在注册 <code>RpcEndpoint</code> 时，每个 <code>RpcEndpoint</code> 都需要有一个唯一的名称。<br>Spark中基于 <code>Netty</code> 实现通信，所以对应的 <code>RpcEnv</code> 实现为 <code>NettyRpcEnv</code>，上面方法的实现，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">setupEndpoint</span></span>(name: <span class="type">String</span>, endpoint: <span class="type">RpcEndpoint</span>): <span class="type">RpcEndpointRef</span> = &#123;</div><div class="line">  dispatcher.registerRpcEndpoint(name, endpoint)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用NettyRpcEnv内部的Dispatcher对象注册一个RpcEndpoint：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">registerRpcEndpoint</span></span>(name: <span class="type">String</span>, endpoint: <span class="type">RpcEndpoint</span>): <span class="type">NettyRpcEndpointRef</span> = &#123;</div><div class="line">  <span class="keyword">val</span> addr = <span class="type">RpcEndpointAddress</span>(nettyEnv.address, name)</div><div class="line">  <span class="keyword">val</span> endpointRef = <span class="keyword">new</span> <span class="type">NettyRpcEndpointRef</span>(nettyEnv.conf, addr, nettyEnv)</div><div class="line">  synchronized &#123;</div><div class="line">    <span class="keyword">if</span> (stopped) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"RpcEnv has been stopped"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (endpoints.putIfAbsent(name, <span class="keyword">new</span> <span class="type">EndpointData</span>(name, endpoint, endpointRef)) != <span class="literal">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">s"There is already an RpcEndpoint called <span class="subst">$name</span>"</span>)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">val</span> data = endpoints.get(name)</div><div class="line">    endpointRefs.put(data.endpoint, data.ref)</div><div class="line">    receivers.offer(data)  <span class="comment">// for the OnStart message</span></div><div class="line">  &#125;</div><div class="line">  endpointRef</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个 RpcEndpoint 只能注册一次（根据 RpcEndpoint 的名称来检查唯一性），这样在 Dispatcher 内部注册并维护 RpcEndpoint 与 RpcEndpointRef 的绑定关系，通过如下两个内部结构：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * A message dispatcher, responsible for routing RPC messages to the appropriate endpoint(s).</div><div class="line"> */</div><div class="line"><span class="keyword">private</span>[netty] <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span>(<span class="params">nettyEnv: <span class="type">NettyRpcEnv</span></span>) <span class="keyword">extends</span> <span class="title">Logging</span> </span>&#123;</div><div class="line"></div><div class="line"><span class="comment">//这里，每一个命名唯一的RpcEndpoint对应一个线程安全的Inbox，所有发送给一个RpcEndpoint的消息，都由对应的Inbox将对应的消息路由给RpcEndpoint进行处理。</span></div><div class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">EndpointData</span>(<span class="params"></span></span></div><div class="line">      val name: <span class="type">String</span>,</div><div class="line">      val endpoint: <span class="type">RpcEndpoint</span>,</div><div class="line">      val ref: <span class="type">NettyRpcEndpointRef</span>) &#123;</div><div class="line">    <span class="keyword">val</span> inbox = <span class="keyword">new</span> <span class="type">Inbox</span>(ref, endpoint)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//一个命名唯一的RpcEndpoint在Dispatcher中对应一个EndpointData来维护其信息</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> endpoints: <span class="type">ConcurrentMap</span>[<span class="type">String</span>, <span class="type">EndpointData</span>] =</div><div class="line">    <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>[<span class="type">String</span>, <span class="type">EndpointData</span>]</div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> endpointRefs: <span class="type">ConcurrentMap</span>[<span class="type">RpcEndpoint</span>, <span class="type">RpcEndpointRef</span>] =</div><div class="line">    <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>[<span class="type">RpcEndpoint</span>, <span class="type">RpcEndpointRef</span>]</div><div class="line"></div><div class="line">  <span class="comment">// Track the receivers whose inboxes may contain messages.</span></div><div class="line">  <span class="keyword">private</span> <span class="keyword">val</span> receivers = <span class="keyword">new</span> <span class="type">LinkedBlockingQueue</span>[<span class="type">EndpointData</span>]</div><div class="line">...</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们来看看RpcEnv的具体内容：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>[spark] <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcEnv</span>(<span class="params">conf: <span class="type">SparkConf</span></span>) </span>&#123;</div><div class="line">	<span class="keyword">private</span>[spark] <span class="keyword">val</span> defaultLookupTimeout = <span class="type">RpcUtils</span>.lookupRpcTimeout(conf)</div><div class="line">	<span class="comment">//返回endpointRef</span></div><div class="line">	<span class="keyword">private</span>[rpc] <span class="function"><span class="keyword">def</span> <span class="title">endpointRef</span></span>(endpoint: <span class="type">RpcEndpoint</span>): <span class="type">RpcEndpointRef</span></div><div class="line">	<span class="comment">//返回RpcEnv监听的地址</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">address</span></span>: <span class="type">RpcAddress</span></div><div class="line">	<span class="comment">//注册一个RpcEndpoint到RpcEnv并返回RpcEndpointRef</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">setupEndpoint</span></span>(name: <span class="type">String</span>, endpoint: <span class="type">RpcEndpoint</span>): <span class="type">RpcEndpointRef</span></div><div class="line">	<span class="comment">//通过uri异步地查询RpcEndpointRef</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">asyncSetupEndpointRefByURI</span></span>(uri: <span class="type">String</span>): <span class="type">Future</span>[<span class="type">RpcEndpointRef</span>]</div><div class="line">	<span class="comment">//通过uri查询RpcEndpointRef，这种方式会产生阻塞</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">setupEndpointRefByURI</span></span>(uri: <span class="type">String</span>): <span class="type">RpcEndpointRef</span> = &#123;</div><div class="line">	defaultLookupTimeout.awaitResult(asyncSetupEndpointRefByURI(uri))</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//通过address和endpointName查询RpcEndpointRef，这种方式会产生阻塞</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">setupEndpointRef</span></span>(address: <span class="type">RpcAddress</span>, endpointName: <span class="type">String</span>): <span class="type">RpcEndpointRef</span> = &#123;</div><div class="line">	setupEndpointRefByURI(<span class="type">RpcEndpointAddress</span>(address, endpointName).toString)</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//关掉endpoint</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(endpoint: <span class="type">RpcEndpointRef</span>): <span class="type">Unit</span></div><div class="line">	<span class="comment">//关掉RpcEnv</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">shutdown</span></span>(): <span class="type">Unit</span></div><div class="line">	<span class="comment">//等待结束</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">awaitTermination</span></span>(): <span class="type">Unit</span></div><div class="line">	<span class="comment">//没有RpcEnv的话RpcEndpointRef是无法被反序列化的，这里是反序列化逻辑</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">deserialize</span></span>[<span class="type">T</span>](deserializationAction: () =&gt; <span class="type">T</span>): <span class="type">T</span></div><div class="line">	<span class="comment">//返回文件server实例</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">fileServer</span></span>: <span class="type">RpcEnvFileServer</span></div><div class="line">	<span class="comment">//开一个针对给定URI的channel用来下载文件</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">openChannel</span></span>(uri: <span class="type">String</span>): <span class="type">ReadableByteChannel</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外RpcEnv有一个伴生对象，实现了create方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">object</span> <span class="title">RpcEnv</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(</div><div class="line">      name: <span class="type">String</span>,</div><div class="line">      host: <span class="type">String</span>,</div><div class="line">      port: <span class="type">Int</span>,</div><div class="line">      conf: <span class="type">SparkConf</span>,</div><div class="line">      securityManager: <span class="type">SecurityManager</span>,</div><div class="line">      clientMode: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">RpcEnv</span> = &#123;</div><div class="line">    <span class="keyword">val</span> config = <span class="type">RpcEnvConfig</span>(conf, name, host, port, securityManager, clientMode)</div><div class="line">    <span class="keyword">new</span> <span class="type">NettyRpcEnvFactory</span>().create(config)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="创建NettyRpcEnv环境对象"><a href="#创建NettyRpcEnv环境对象" class="headerlink" title="创建NettyRpcEnv环境对象"></a>创建NettyRpcEnv环境对象</h3><p>创建NettyRpcEnv对象，是一个非常重的操作，所以在框架里使用过程中要尽量避免重复创建。创建NettyRpcEnv，会创建很多用来处理底层RPC通信的线程和数据结构。具体的创建过程，如下图所示：<br><img src="/resources/bigdata/SparkRPC-Create-NettyRpcEnv.png" alt="Spark NettyRpcEnv"><br>具体要点，描述如下：</p>
<ul>
<li>创建一个NettyRpcEnv对象对象，需要通过NettyRpcEnvFactory来创建</li>
<li>Dispatcher负责RPC消息的路由，它能够将消息路由到对应的RpcEndpoint进行处理</li>
<li>NettyStreamManager负责提供文件服务（文件、JAR文件、目录）</li>
<li>NettyRpcHandler负责处理网络IO事件，接收RPC调用请求，并通过Dispatcher派发消息</li>
<li>TransportContext负责管理网路传输上下文信息：创建MessageEncoder、MessageDecoder、TransportClientFactory、TransportServer</li>
<li>TransportServer配置并启动一个RPC Server服务</li>
</ul>
<h2 id="RpcEndpoint特质"><a href="#RpcEndpoint特质" class="headerlink" title="RpcEndpoint特质"></a>RpcEndpoint特质</h2><p><code>RpcEndpoint</code> 定义了 <code>RPC</code> 通信过程中的通信端对象，除了具有管理一个 RpcEndpoint 生命周期的操作<code>（constructor -&gt; onStart -&gt; receive* -&gt; onStop）</code>，并给出了通信过程中一个 <code>RpcEndpoint</code> 所具有的基于事件驱动的行为（连接、断开、网络异常），实际上对于Spark框架来说主要是接收消息并处理，具体可以看对应特质 <code>RpcEndpoint</code> 的代码定义，如下所示:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">trait</span> <span class="title">RpcEndpoint</span> </span>&#123;</div><div class="line">  <span class="comment">//当前RpcEndpoint注册到的RpcEnv主子，可以类比为Akka中的actorSystem</span></div><div class="line">  <span class="keyword">val</span> rpcEnv: <span class="type">RpcEnv</span></div><div class="line">  <span class="comment">//直接用来发送消息的RpcEndpointRef，可以类比为Akka中的actorRef</span></div><div class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">self</span></span>: <span class="type">RpcEndpointRef</span> = &#123;</div><div class="line">    require(rpcEnv != <span class="literal">null</span>, <span class="string">"rpcEnv has not been initialized"</span>)</div><div class="line">    rpcEnv.endpointRef(<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//处理来自RpcEndpointRef.send或者RpcCallContext.reply的消息</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</div><div class="line">    <span class="keyword">case</span> _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(self + <span class="string">" does not implement 'receive'"</span>)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//处理来自RpcEndpointRef.ask的消息，会有相应的回复</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">receiveAndReply</span></span>(context: <span class="type">RpcCallContext</span>): <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</div><div class="line">    <span class="keyword">case</span> _ =&gt; context.sendFailure(<span class="keyword">new</span> <span class="type">SparkException</span>(self + <span class="string">" won't reply anything"</span>))</div><div class="line">  &#125;</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onError</span></span>(cause: <span class="type">Throwable</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="comment">// By default, throw e and let RpcEnv handle it</span></div><div class="line">    <span class="keyword">throw</span> cause</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onConnected</span></span>(remoteAddress: <span class="type">RpcAddress</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="comment">// By default, do nothing.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onDisconnected</span></span>(remoteAddress: <span class="type">RpcAddress</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="comment">// By default, do nothing.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onNetworkError</span></span>(cause: <span class="type">Throwable</span>, remoteAddress: <span class="type">RpcAddress</span>): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="comment">// By default, do nothing.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="comment">// By default, do nothing.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">onStop</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="comment">// By default, do nothing.</span></div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">stop</span></span>(): <span class="type">Unit</span> = &#123;</div><div class="line">    <span class="keyword">val</span> _self = self</div><div class="line">    <span class="keyword">if</span> (_self != <span class="literal">null</span>) &#123;</div><div class="line">      rpcEnv.stop(_self)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="RpcEndpointRef"><a href="#RpcEndpointRef" class="headerlink" title="RpcEndpointRef"></a>RpcEndpointRef</h2><p><code>RpcEndpointRef</code> 是一个对 <code>RpcEndpoint</code> 的远程引用对象，通过它可以向远程的 <code>RpcEndpoint</code> 端发送消息以进行通信。<code>RpcEndpointRef</code> 特质的定义，代码如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span>[spark] <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RpcEndpointRef</span>(<span class="params">conf: <span class="type">SparkConf</span></span>)  <span class="keyword">extends</span> <span class="title">Serializable</span> <span class="keyword">with</span> <span class="title">Logging</span> </span>&#123; </div><div class="line"></div><div class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> maxRetries = <span class="type">RpcUtils</span>.numRetries(conf)</div><div class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> retryWaitMs = <span class="type">RpcUtils</span>.retryWaitMs(conf)</div><div class="line">  <span class="keyword">private</span>[<span class="keyword">this</span>] <span class="keyword">val</span> defaultAskTimeout = <span class="type">RpcUtils</span>.askRpcTimeout(conf)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">address</span></span>: <span class="type">RpcAddress</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">name</span></span>: <span class="type">String</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">send</span></span>(message: <span class="type">Any</span>): <span class="type">Unit</span></div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ask</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](message: <span class="type">Any</span>, timeout: <span class="type">RpcTimeout</span>): <span class="type">Future</span>[<span class="type">T</span>]</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">ask</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](message: <span class="type">Any</span>): <span class="type">Future</span>[<span class="type">T</span>] = ask(message, defaultAskTimeout)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">askWithRetry</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](message: <span class="type">Any</span>): <span class="type">T</span> = askWithRetry(message, defaultAskTimeout)</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">askWithRetry</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](message: <span class="type">Any</span>, timeout: <span class="type">RpcTimeout</span>): <span class="type">T</span> = &#123;</div><div class="line">    ... ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，send 方法发送消息后不等待响应，亦即 Send-and-forget ，Spark中基于 Netty 实现，实现在 NettyRpcEndpointRef 中，如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">send</span></span>(message: <span class="type">Any</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  require(message != <span class="literal">null</span>, <span class="string">"Message is null"</span>)</div><div class="line">  nettyEnv.send(<span class="type">RequestMessage</span>(nettyEnv.address, <span class="keyword">this</span>, message))</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可见，它是通过 <code>NettyRpcEnv</code> 来发送 <code>RequestMessage</code> 消息，并将当前 <code>NettyRpcEndpointRef</code> 封装到 <code>RequestMessage</code> 消息对象中发送出去，通信对端通过该 <code>NettyRpcEndpointRef</code> 能够识别出消息来源。</p>
<p>而ask方法发送消息后需要等待通信对端给予响应，通过 <code>Future</code> 来异步获取响应结果，也是在 <code>NettyRpcEndpointRef</code> 中实现，如下所示:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">ask</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](message: <span class="type">Any</span>, timeout: <span class="type">RpcTimeout</span>): <span class="type">Future</span>[<span class="type">T</span>] = &#123;</div><div class="line">  nettyEnv.ask(<span class="type">RequestMessage</span>(nettyEnv.address, <span class="keyword">this</span>, message), timeout)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>类似的，也是通过 <code>NettyRpcEnv</code> 来发送一个 <code>RequestMessage</code> 消息。</p>
<h2 id="消息路由过程分析"><a href="#消息路由过程分析" class="headerlink" title="消息路由过程分析"></a>消息路由过程分析</h2><p>基于Standalone模式，Spark集群具有Master和一组Worker，Worker与Master之间需要进行通信，我们以此为例，来说明基于Spark PRC层是如何实现消息的路由的。<br>首先看Master端实现，代码如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">startRpcEnvAndEndpoint</span></span>(</div><div class="line">    host: <span class="type">String</span>,</div><div class="line">    port: <span class="type">Int</span>,</div><div class="line">    webUiPort: <span class="type">Int</span>,</div><div class="line">    conf: <span class="type">SparkConf</span>): (<span class="type">RpcEnv</span>, <span class="type">Int</span>, <span class="type">Option</span>[<span class="type">Int</span>]) = &#123;</div><div class="line">  <span class="keyword">val</span> securityMgr = <span class="keyword">new</span> <span class="type">SecurityManager</span>(conf)</div><div class="line">  <span class="keyword">val</span> rpcEnv = <span class="type">RpcEnv</span>.create(<span class="type">SYSTEM_NAME</span>, host, port, conf, securityMgr)</div><div class="line">  <span class="keyword">val</span> masterEndpoint = rpcEnv.setupEndpoint(<span class="type">ENDPOINT_NAME</span>,</div><div class="line">    <span class="keyword">new</span> <span class="type">Master</span>(rpcEnv, rpcEnv.address, webUiPort, securityMgr, conf))</div><div class="line">  <span class="keyword">val</span> portsResponse = masterEndpoint.askWithRetry[<span class="type">BoundPortsResponse</span>](<span class="type">BoundPortsRequest</span>)</div><div class="line">  (rpcEnv, portsResponse.webUIPort, portsResponse.restPort)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面代码中，创建一个RpcEnv对象，通过创建一个NettyRpcEnvFactory对象来完成该RpcEnv对象的创建，实际创建了一个NettyRpcEnv对象。接着，通过setupEndpoint方法注册一个RpcEndpoint，这里Master就是一个RpcEndpoint，返回的masterEndpoint是Master的RpcEndpointRef引用对象。下面，我们看一下，发送一个BoundPortsRequest消息，具体的消息路由过程，如下图所示：<br><img src="/resources/bigdata/Master-startRpcEnvAndEndpoint.png" alt="Spark NettyRpcEnv"><br>上图中显示本地消息和远程消息派发的流程，最主要的区别是在接收消息时：接收消息走的是Inbox，发送消息走的是Outbox。</p>
<h3 id="本地消息路由"><a href="#本地消息路由" class="headerlink" title="本地消息路由"></a>本地消息路由</h3><p>发送一个BoundPortsRequest消息，实际走的是本地消息路由，直接放到对应的Inbox中，对应的代码处理逻辑如下所示：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">postMessage</span></span>(</div><div class="line">    endpointName: <span class="type">String</span>,</div><div class="line">    message: <span class="type">InboxMessage</span>,</div><div class="line">    callbackIfStopped: (<span class="type">Exception</span>) =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</div><div class="line">  <span class="keyword">val</span> error = synchronized &#123;</div><div class="line">    <span class="keyword">val</span> data = endpoints.get(endpointName)</div><div class="line">    <span class="keyword">if</span> (stopped) &#123;</div><div class="line">      <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">RpcEnvStoppedException</span>())</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data == <span class="literal">null</span>) &#123;</div><div class="line">      <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s"Could not find <span class="subst">$endpointName</span>."</span>))</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      data.inbox.post(message)</div><div class="line">      receivers.offer(data)</div><div class="line">      <span class="type">None</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// We don't need to call `onStop` in the `synchronized` block</span></div><div class="line">  error.foreach(callbackIfStopped)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>上面通过data.inbox派发消息，然后将消息data :EndpointData放入到receivers队列，触发Dispatcher内部的MessageLoop线程去消费，如下所示：</p>
<p>private class MessageLoop extends Runnable {<br>  override def run(): Unit = {<br>    try {<br>      while (true) {<br>        try {<br>          val data = receivers.take()<br>          if (data == PoisonPill) {<br>            // Put PoisonPill back so that other MessageLoops can see it.<br>            receivers.offer(PoisonPill)<br>            return<br>          }<br>          data.inbox.process(Dispatcher.this)<br>        } catch {<br>          case NonFatal(e) =&gt; logError(e.getMessage, e)<br>        }<br>      }<br>    } catch {<br>      case ie: InterruptedException =&gt; // exit<br>    }<br>  }<br>}</p>
<p>这里，又继续调用Inbox的process方法来派发消息到指定的RpcEndpoint。通过上面的序列图，我们可以通过源码分析看到，原始消息被层层封装为一个RpcMessage ，该消息在Inbox的process方法中处理派发逻辑，如下所示：</p>
<p>case RpcMessage(_sender, content, context) =&gt;<br>       try {<br>         endpoint.receiveAndReply(context).applyOrElse<a href="content, { msg =&gt;
           throw new SparkException(s&quot;Unsupported message $message from ${_sender}&quot;">Any, Unit</a><br>         })<br>       } catch {<br>         case NonFatal(e) =&gt;<br>           context.sendFailure(e)<br>           // Throw the exception – this exception will be caught by the safelyCall function.<br>           // The endpoint’s onError function will be called.<br>           throw e<br>       }</p>
<p>到这里，消息已经发送给对应的RpcEndpoint的receiveAndReply方法，我们这里实际上是Master实现类，这里的消息解包后为content: BoundPortsRequest，接下来应该看Master的receiveAndReply方法如何处理该本地消息，代码如下所示：<br>case BoundPortsRequest =&gt;<br>  context.reply(BoundPortsResponse(address.port, webUi.boundPort, restServerBoundPort))<br>可以看出，实际上上面的处理逻辑没有什么处理，只是通过BoundPortsResponse返回了几个Master端的几个端口号数据。  </p>
<h3 id="远程消息路由"><a href="#远程消息路由" class="headerlink" title="远程消息路由"></a>远程消息路由</h3><p>我们都知道，Worker启动时，会向Master注册，通过该场景我们分析一下远程消息路由的过程。<br>先看一下Worker端向Master注册过程，如下图所示：<br><img src="/resources/bigdata/Worker.ask_.png" alt="Spark NettyRpcEnv"></p>
<p>Worker启动时，会首先获取到一个Master的RpcEndpointRef远程引用，通过该引用对象能够与Master进行RPC通信，经过上面消息派发，最终通过Netty的Channel将消息发送到远程Master端。<br>通过前面说明，我们知道Worker向Master注册的消息RegisterWorker应该最终会被路由到Master对应的Inbox中，然后派发给Master进行处理。下面，我们看一下Master端接收并处理消息的过程，如下图所示：<br><img src="/resources/bigdata/Master.receiveAndReply.png" alt="Spark NettyRpcEnv"><br>上图分为两部分：一部分是从远端接收消息RegisterWorker，将接收到的消息放入到Inbox中；另一部分是触发MessageLoop线程处理该消息，进而通过调用Inbox的process方法，继续调用RpcEndpoint（Master）的receiveAndReply方法，处理消息RegisterWorker，如下所示：<br>case RegisterWorker(<br>    id, workerHost, workerPort, workerRef, cores, memory, workerWebUiUrl) =&gt;<br>  logInfo(“Registering worker %s:%d with %d cores, %s RAM”.format(<br>    workerHost, workerPort, cores, Utils.megabytesToString(memory)))<br>  if (state == RecoveryState.STANDBY) {<br>    context.reply(MasterInStandby)<br>  } else if (idToWorker.contains(id)) {<br>    context.reply(RegisterWorkerFailed(“Duplicate worker ID”))<br>  } else {<br>    val worker = new WorkerInfo(id, workerHost, workerPort, cores, memory,<br>      workerRef, workerWebUiUrl)<br>    if (registerWorker(worker)) {<br>      persistenceEngine.addWorker(worker)<br>      context.reply(RegisteredWorker(self, masterWebUiUrl))<br>      schedule()<br>    } else {<br>      val workerAddress = worker.endpoint.address<br>      logWarning(“Worker registration failed. Attempted to re-register worker at same “ +<br>        “address: “ + workerAddress)<br>      context.reply(RegisterWorkerFailed(“Attempted to re-register worker at same address: “</p>
<pre><code>    + workerAddress))
}
</code></pre><p>  }</p>
<p>如果Worker注册成功，则Master会通过context对象回复Worker响应：<br>context.reply(RegisteredWorker(self, masterWebUiUrl))<br>这样，如果一切正常，则Worker会收到RegisteredWorker响应消息，从而获取到Master的RpcEndpointRef引用对象，能够通过该引用对象与Master交互。</p>
</div><div class="tags"><a href="/tags/spark/">spark</a><a href="/tags/rpc/">rpc</a></div><div class="post-share"></div><div class="post-nav"><a href="/2017/09/27/2017-09-27.不朽的失眠/" class="pre">不朽的失眠</a><a href="/2016/06/14/duoshuo-disqus-comment-count/" class="next">获取多说和 Disqus 文章评论数的方法</a></div><div id="comments"></div></div></div></div><div class="layout-r"><div id="sidebar"><div class="search-pla"></div><div id="toc" class="widget"><div class="widget-title"><i class="fa fa-fei">文章目录</i></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Spark-RPC"><span class="toc-text">Spark RPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RpcEnvFactory"><span class="toc-text">RpcEnvFactory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RpcEnv"><span class="toc-text">RpcEnv</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RpcEnv抽象类"><span class="toc-text">RpcEnv抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建NettyRpcEnv环境对象"><span class="toc-text">创建NettyRpcEnv环境对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RpcEndpoint特质"><span class="toc-text">RpcEndpoint特质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RpcEndpointRef"><span class="toc-text">RpcEndpointRef</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#消息路由过程分析"><span class="toc-text">消息路由过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#本地消息路由"><span class="toc-text">本地消息路由</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#远程消息路由"><span class="toc-text">远程消息路由</span></a></li></ol></li></ol></div><div class="widget"><div class="widget-title"><i class="fa fa-xie"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/09/27/2017-09-27.不朽的失眠/">不朽的失眠</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/12/30/2016-12-30.Spark RPC通信层分析/">Spark RPC通信层分析</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/14/duoshuo-disqus-comment-count/">获取多说和 Disqus 文章评论数的方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/13/hexo-collapsible-toc/">为 Hexo 添加可折叠的文章目录</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/31/hexo-local-search/">让 Hexo 博客支持本地站内搜索</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/17/image-compression/">关于 Yelee 主题背景图的压缩与优化</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/11/public-dns/">几个国内专用的公共 DNS</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/20/baidu-share-fontawesome/">在百度分享中使用 Font Awesome 图标</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/04/18/text-overflow-ellipsis/">CSS 设置文本省略 ellipsis (…)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/03/27/hexo-browsersync/">Hexo 页面自动刷新与移动端调试</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-gui"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/spark/">spark</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/散文/">散文</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/术业专攻/">术业专攻</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/自用笔记/">自用笔记</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/自用笔记/术业专攻/">术业专攻</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/触类旁通/">触类旁通</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-biao"> 标签</i></div><div class="tagcloud"><a href="/tags/PhotoShop/" style="font-size: 15px;">PhotoShop</a> <a href="/tags/HTML/" style="font-size: 15px;">HTML</a> <a href="/tags/JavaScript/" style="font-size: 15px;">JavaScript</a> <a href="/tags/Git/" style="font-size: 15px;">Git</a> <a href="/tags/EndNote/" style="font-size: 15px;">EndNote</a> <a href="/tags/Markdown/" style="font-size: 15px;">Markdown</a> <a href="/tags/Reference/" style="font-size: 15px;">Reference</a> <a href="/tags/Windows/" style="font-size: 15px;">Windows</a> <a href="/tags/Mac/" style="font-size: 15px;">Mac</a> <a href="/tags/Software/" style="font-size: 15px;">Software</a> <a href="/tags/多说/" style="font-size: 15px;">多说</a> <a href="/tags/UA/" style="font-size: 15px;">UA</a> <a href="/tags/Hexo/" style="font-size: 15px;">Hexo</a> <a href="/tags/TagCloud/" style="font-size: 15px;">TagCloud</a> <a href="/tags/Excel/" style="font-size: 15px;">Excel</a> <a href="/tags/Table/" style="font-size: 15px;">Table</a> <a href="/tags/GitHub/" style="font-size: 15px;">GitHub</a> <a href="/tags/CSS/" style="font-size: 15px;">CSS</a> <a href="/tags/GIF/" style="font-size: 15px;">GIF</a> <a href="/tags/PNG/" style="font-size: 15px;">PNG</a> <a href="/tags/PowerPoint/" style="font-size: 15px;">PowerPoint</a> <a href="/tags/Anki/" style="font-size: 15px;">Anki</a> <a href="/tags/Sublime/" style="font-size: 15px;">Sublime</a> <a href="/tags/font-family/" style="font-size: 15px;">font-family</a> <a href="/tags/Browsersync/" style="font-size: 15px;">Browsersync</a> <a href="/tags/Font-Awesome/" style="font-size: 15px;">Font-Awesome</a> <a href="/tags/DNS/" style="font-size: 15px;">DNS</a> <a href="/tags/Yelee/" style="font-size: 15px;">Yelee</a> <a href="/tags/jQuery/" style="font-size: 15px;">jQuery</a> <a href="/tags/Disqus/" style="font-size: 15px;">Disqus</a> <a href="/tags/JSON/" style="font-size: 15px;">JSON</a> <a href="/tags/spark/" style="font-size: 15px;">spark</a> <a href="/tags/rpc/" style="font-size: 15px;">rpc</a> <a href="/tags/散文/" style="font-size: 15px;">散文</a> <a href="/tags/WordPress/" style="font-size: 15px;">WordPress</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-archive"> 归档</i></div><ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/02/">二月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/01/">一月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/12/">十二月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/11/">十一月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/10/">十月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">九月 2015</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/08/">八月 2015</a></li></ul></div></div></div></div><a id="totop" href="#top"></a><div id="footer"><div class="footer-info"><p><!--a(href=config.root+"about/")= __("about")--></p><p><span> Copyright &copy;<a href="/." rel="nofollow">xcoder.</a></span><span> Theme by<a rel="nofollow" target="_blank" href="https://github.com/chaooo/hexo-theme-BlueLake"> BlueLake.</a></span><span> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a></span></p></div></div></div><script type="text/javascript" src="/js/search.json.js?v=2.0.1"></script><script type="text/javascript" src="/js/toctotop.js?v=2.0.1" async></script></body></html>